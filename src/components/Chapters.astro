---
import RecurringImages from "@store/RecurringImages";

const { green_book, green_right_arrow } = RecurringImages;

declare interface Props {
  fixedTop?: boolean;
  desktopOnly?: boolean;
  headingName: string;
  headings: NodeListOf<HTMLHeadingElement>;
  staticHeadings: string[];
}

const { fixedTop, desktopOnly, headingName, headings, staticHeadings } =
  Astro.props as Props;

const dynamicHeadings = headings
  ? Array.from(headings, ({ innerText }) => innerText)
  : [];

const headingTexts = dynamicHeadings || staticHeadings;
---

<style lang="scss">
  @use "src/styles/colors";

  #sticky-chapters.invisible{
    height: 0;
  }

  a {
    &.chapter-link,
    &.chapter-link-sm {
      &.active {
        font-weight: 700;
        color: colors.$primary;
      }

      &:not(.active) img {
        opacity: 0;
      }
    }
  }
</style>

<div
  role="complementary"
  aria-label={headingName}
  id={fixedTop ? "sticky-chapters" : "headings"}
  class:list={[
    "overflow-hidden sticky",
    fixedTop
      ? "w-full invisible md:hidden z-10 top-0 bg-secondary shadow-[0_4px_5px_gray]"
      : "md:w-1/3 2xl:w-1/2 px-[15px] md:px-0 h-full md:top-0",
    desktopOnly && "hidden md:block",
  ]}
>
  <div
    class:list={[
      fixedTop
        ? "flex flex-col wrapper relative select-none"
        : "w-full md:max-w-[484px] ml-auto grid gap-[25px] sm:gap-[30px]",
    ]}
  >
    <div
      id={fixedTop && "sticky-dropdown-toggle"}
      class={fixedTop &&
        "flex items-center gap-2.5 py-[15px] sm:pt-6 cursor-pointer focus:outline-none"}
    >
      {
        fixedTop && (
          <div class="w-[25px] min-w-[25px]">
            <img class="w-full h-full" {...green_book} />
          </div>
        )
      }

      <h3
        id={fixedTop && "sticky-chapters-heading"}
        class:list={[
          "text-black",
          fixedTop
            ? "grow text-sm font-medium"
            : "text-[clamp(24px,calc(1vw+17.6px),32px)] font-bold",
        ]}
      >
        {headingName}
      </h3>

      {
        fixedTop && (
          <svg
            viewBox="0 0 11.6 6.7"
            xmlns="http://www.w3.org/2000/svg"
            id="sticky-dropdown-toggle-icon"
            class="w-[14px] min-w-[14px] fill-primary"
          >
            <path d="M.3.3A.6.6 0 0 1 .9 0a.9.9 0 0 1 .6.3l4.3 4.3L10.2.3a.6.6 0 0 1 .6-.3l.6.3a.8.8 0 0 1 .2.6.7.7 0 0 1-.2.6l-5 4.9a.6.6 0 0 1-.6.3.9.9 0 0 1-.6-.3L.3 1.5A.9.9 0 0 1 0 .9.6.6 0 0 1 .3.3Z" />
          </svg>
        )
      }
    </div>

    <div
      class:list={[
        "grid gap-[25px] md:gap-[30px] overflow-y-auto",
        fixedTop && "hidden py-[25px] border-t border-primary-light",
      ]}
    >
      <slot name="top-slot" />

      <div
        role="list"
        id={fixedTop ? "sticky-chapter-links" : "chapter-links"}
        class:list={[
          "grid gap-2.5 md:gap-[15px] overflow-y-auto",
          fixedTop && "max-h-[50vh]",
        ]}
      >
        {
          headingTexts.map((title, i) => (
            <a
              href={`#${title?.toLowerCase()?.replaceAll(" ", "-")}`}
              role="listitem"
              class:list={[
                "chapter-link inline-flex items-center",
                "gap-[clamp(10px,calc(0.625vw+6px),15px)]",
                "text-[clamp(18px,calc(0.75vw+13.2px),24px)] text-black-light",
                fixedTop && "chapter-link-sm",
                i === 0 && "active",
              ]}
            >
              <div class="min-w-[clamp(35px,calc(1.25vw+27px),45px)]">
                <img src={green_right_arrow.src} alt="" />
              </div>

              <div>{title}</div>
            </a>
          ))
        }
      </div>

      <slot />
    </div>
  </div>

  {
    fixedTop && (
      <div
        id="reading-progress-bar"
        class="py-[2.5px] bg-primary rounded-r-full duration-150"
      />
    )
  }
</div>

<script defer>
  {
    const query = document.querySelector.bind(document),
      queryAll = document.querySelectorAll.bind(document);

    const header = query("#navigation"),
      headings = query("#headings"),
      postDetails = query("#post-details"),
      chapters = [...queryAll("#post-details .chapter")],
      [firstChapter] = chapters,
      stickyChapters = query("#sticky-chapters"),
      stickyChaptersHeading = query("#sticky-chapters-heading"),
      stickyDropdownToggle = query("#sticky-dropdown-toggle"),
      chapterLinks = [...queryAll(".chapter-link")],
      stickyChapterLinks = [...queryAll(".chapter-link-sm")],
      chapterLinksContainer = query("#chapter-links"),
      stickyChapterLinksContainer = query("#sticky-chapter-links"),
      headingIDs = chapterLinks.map((link) => link.hash.slice(1)),
      [firstHeadingID] = headingIDs,
      readingProgressBar = query("#reading-progress-bar");

    const isChapterOnScreen = (chapterElement) => {
      const { top, bottom } = chapterElement.getBoundingClientRect(),
        topSafeAreaHeight =
          window.innerWidth < 768
            ? readingProgressBar.getBoundingClientRect().bottom
            : 0,
        // consider a chapter element on screen only if it's at least 50px on screen
        bottomSafeAreaHeight = 50;

      if (
        top < window.innerHeight - bottomSafeAreaHeight &&
        bottom > topSafeAreaHeight
      )
        return true;

      return false;
    };

    const getActiveChapter = (visibleChapters) => {
      const activeChapter =
        visibleChapters.find((chapterElement) =>
          isChapterOnScreen(chapterElement.firstElementChild),
        ) ||
        visibleChapters[0] ||
        chapters[0];

      return activeChapter;
    };

    const styleActiveChapter = () => {
      const visibleChapters = chapters.filter(isChapterOnScreen),
        // mark first chapter on screen as active and fallback to the first chapter
        activeChapter = getActiveChapter(visibleChapters),
        activeChapterIndex = chapters.indexOf(activeChapter),
        activeChapterHeading = activeChapter.querySelector("h2");

      [...chapterLinks, ...stickyChapterLinks].forEach((link) =>
        link.classList.remove("active"),
      );

      // highlight active chapter link
      chapterLinks[activeChapterIndex].classList.add("active");
      stickyChapterLinks[activeChapterIndex].classList.add("active");

      const containerRect = postDetails.getBoundingClientRect(),
        { bottom: headerBottom } = header.getBoundingClientRect();

      const displayStickyChapters =
        window.innerWidth < 768 &&
        firstChapter.getBoundingClientRect().y - headerBottom < 0 &&
        visibleChapters.length > 0;

      if (displayStickyChapters) {
        stickyChapters.style.top =
          headerBottom - (window.innerWidth >= 640 ? 10 : 0) + "px";

        stickyChaptersHeading.textContent = activeChapterHeading.textContent;

        const readPixels = Math.abs(containerRect.y - window.innerHeight),
          detailedBlogHeight = containerRect.height,
          minProgress =
            ((window.innerHeight - headerBottom) / detailedBlogHeight) * 100,
          progress = (readPixels / detailedBlogHeight) * 100,
          correctedProgress =
            ((progress - minProgress) / (100 - minProgress)) * 100;

        // update progress meter
        readingProgressBar.style.width = `${correctedProgress}%`;
      } else if (window.innerWidth >= 768) {
        headings.style.top = headerBottom + 25 + "px";
      }

      // display sticky chapters
      stickyChapters.classList[displayStickyChapters ? "remove" : "add"](
        "invisible",
      );

      const [visibleChapterLinks, visibleLinksContainer] =
        window.innerWidth >= 768 && isChapterOnScreen(chapterLinksContainer)
          ? [chapterLinks, chapterLinksContainer]
          : !stickyChapterLinksContainer.parentElement.classList.contains(
              "hidden",
            )
          ? [stickyChapterLinks, stickyChapterLinksContainer]
          : [];

      if (visibleLinksContainer) {
        const activeHeadingLink = visibleChapterLinks[activeChapterIndex];

        visibleLinksContainer.style.height = "auto";

        const visibleLinksContainerHeight =
          visibleLinksContainer.getBoundingClientRect().height;

        visibleLinksContainer.style.flexGrow = 1;

        const availableHeight =
          visibleLinksContainer.getBoundingClientRect().height;

        const containerHeight = Math.min(
          visibleLinksContainerHeight,
          availableHeight,
        );

        visibleLinksContainer.style.flexGrow = 0;

        visibleLinksContainer.style.height = containerHeight + "px";

        visibleLinksContainer.scrollTop =
          activeHeadingLink.offsetTop - containerHeight;
      }
    };

    styleActiveChapter();

    window.addEventListener("scroll", styleActiveChapter);
    window.addEventListener("resize", styleActiveChapter);

    stickyDropdownToggle.addEventListener("click", () => {
      stickyChapterLinksContainer.parentElement.classList.toggle("hidden");
    });

    // collapse dropdown when an item is clicked
    [...document.links].forEach((link) => {
      if (link.hash && headingIDs.includes(link.hash.slice(1))) {
        link.addEventListener("click", (event) => {
          event.preventDefault();

          const headingID = link.hash.slice(1),
            heading = document.getElementById(headingID),
            headerHeight = header.getBoundingClientRect().height;

          let blockedAreaBottom = headerHeight;

          if (window.innerWidth < 768) {
            const isFirstHeadingLink = firstHeadingID === headingID;

            stickyChapterLinksContainer.parentElement.classList.add("hidden");

            const stickyChaptersHeight =
              stickyChapters.getBoundingClientRect().height;

            blockedAreaBottom += isFirstHeadingLink
              ? 10
              : stickyChaptersHeight - 10;
          }

          const { offsetTop: headingOffsetTop } = heading;

          window.scrollTo({
            top: headingOffsetTop - blockedAreaBottom,
          });
        });
      }
    });
  }
</script>

