<script defer>
  {
    const query = document.querySelector.bind(document),
      queryAll = document.querySelectorAll.bind(document);

    const navbar = query("#navigation"),
      postDetails = query("#post-details"),
      chapters = [...queryAll("#post-details .chapter")],
      [firstChapter] = chapters,
      stickyHeader = query("#sticky-header"),
      stickyHeaderHeading = query("#sticky-header-heading"),
      stickyDropdownToggle = query("#sticky-dropdown-toggle"),
      headingLinks = [...queryAll(".chapter-link")],
      stickyHeadingLinks = [...queryAll(".chapter-link-sm")],
      headingLinksContainer = query("#heading-links"),
      stickyHeadingLinksContainer = query("#sticky-heading-links"),
      headingIDs = headingLinks.map((link) => link.hash.slice(1)),
      [firstHeadingID] = headingIDs,
      readingProgressBar = query("#reading-progress-bar");

    const isChapterOnScreen = (chapterElement) => {
      const { top, bottom } = chapterElement.getBoundingClientRect(),
        topSafeAreaHeight =
          window.innerWidth < 768
            ? readingProgressBar.getBoundingClientRect().bottom
            : 0,
        // consider a chapter element on screen only if it's at least 50px on screen
        bottomSafeAreaHeight = 50;

      if (
        top < window.innerHeight - bottomSafeAreaHeight &&
        bottom > topSafeAreaHeight
      )
        return true;

      return false;
    };

    const getActiveChapter = () => {
      const visibleChapters = chapters.filter(isChapterOnScreen);

      const activeChapter =
        visibleChapters.find((chapterElement) =>
          isChapterOnScreen(chapterElement.firstElementChild),
        ) ||
        visibleChapters[0] ||
        chapters[0];

      return activeChapter;
    };

    const styleActiveChapter = () => {
      // mark first chapter on screen as active and fallback to the first chapter
      const activeChapter = getActiveChapter(),
        activeChapterIndex = chapters.indexOf(activeChapter),
        activeChapterHeading = activeChapter.querySelector("h2");

      [...headingLinks, ...stickyHeadingLinks].forEach((link) =>
        link.classList.remove("active"),
      );

      // highlight active chapter link
      headingLinks[activeChapterIndex].classList.add("active");
      stickyHeadingLinks[activeChapterIndex].classList.add("active");

      const { bottom: navbarBottom } = navbar.getBoundingClientRect(),
        displayStickyHeader =
          window.innerWidth < 768 &&
          firstChapter.getBoundingClientRect().y - navbarBottom < 0;

      if (displayStickyHeader) {
        stickyHeader.style.top = navbarBottom + "px";

        stickyHeaderHeading.textContent = activeChapterHeading.textContent;

        const containerRect = postDetails.getBoundingClientRect(),
          readPixels = Math.abs(containerRect.y - window.innerHeight),
          detailedBlogHeight = containerRect.height,
          minProgress =
            ((window.innerHeight - navbarBottom) / detailedBlogHeight) * 100,
          progress = (readPixels / detailedBlogHeight) * 100,
          correctedProgress =
            ((progress - minProgress) / (100 - minProgress)) * 100;

        // update progress meter
        readingProgressBar.style.width = `${correctedProgress}%`;
      }

      // display sticky header
      stickyHeader.classList[displayStickyHeader ? "remove" : "add"](
        "invisible",
      );

      const [visibleHeadingLinks, visibleLinksContainer] =
        window.innerWidth >= 768 && isChapterOnScreen(headingLinksContainer)
          ? [headingLinks, headingLinksContainer]
          : !stickyHeadingLinksContainer.parentElement.classList.contains(
              "hidden",
            )
          ? [stickyHeadingLinks, stickyHeadingLinksContainer]
          : [];

      if (visibleLinksContainer) {
        const activeHeadingLink = visibleHeadingLinks[activeChapterIndex];

        visibleLinksContainer.style.height = "auto";

        const visibleLinksContainerHeight =
          visibleLinksContainer.getBoundingClientRect().height;

        visibleLinksContainer.style.flexGrow = 1;

        const availableHeight =
          visibleLinksContainer.getBoundingClientRect().height;

        const containerHeight = Math.min(
          visibleLinksContainerHeight,
          availableHeight,
        );

        visibleLinksContainer.style.flexGrow = 0;

        visibleLinksContainer.style.height = containerHeight + "px";

        visibleLinksContainer.scrollTop =
          activeHeadingLink.offsetTop - containerHeight;
      }
    };

    styleActiveChapter();

    window.addEventListener("scroll", styleActiveChapter);
    window.addEventListener("resize", styleActiveChapter);

    stickyDropdownToggle.addEventListener("click", () => {
      stickyHeadingLinksContainer.parentElement.classList.toggle("hidden");
    });

    // collapse dropdown when an item is clicked
    [...document.links].forEach((link) => {
      if (link.hash && headingIDs.includes(link.hash.slice(1))) {
        link.addEventListener("click", (event) => {
          event.preventDefault();

          const headingID = link.hash.slice(1),
            heading = document.getElementById(headingID);

          let blockedAreaBottom = 0;

          if (window.innerWidth < 640) {
            const isFirstHeadingLink = firstHeadingID === headingID;

            stickyHeadingLinksContainer.parentElement.classList.add("hidden");

            const navbarHeight = navbar.getBoundingClientRect().height,
              stickyHeaderHeight = stickyHeader.getBoundingClientRect().height;

            blockedAreaBottom =
              navbarHeight +
              (isFirstHeadingLink ? 10 : stickyHeaderHeight - 10);
          }

          const { offsetTop: headingOffsetTop } = heading;

          window.scrollTo({
            top: headingOffsetTop - blockedAreaBottom,
          });
        });
      }
    });
  }
</script>
