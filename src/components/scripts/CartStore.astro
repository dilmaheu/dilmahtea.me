---
import productsStore from "@store/products";
import localizeCMSImage from "@utils/localizeCMSImage";

const products = Object.fromEntries(
  await Promise.all(
    productsStore.get("all").data.map(async ({ attributes }) => {
      const { SKU: sku, Price } = attributes;

      const tax = Math.round(Price * 9) / 100,
        price = Math.round((Price + tax) * 100) / 100,
        image = await localizeCMSImage(
          attributes.Intro_blob.data.attributes.formats.thumbnail.url
        );

      const names = JSON.stringify(
        Object.fromEntries(
          [{ attributes }, ...attributes.localizations.data].map(
            ({ attributes: { locale, Title } }) => [
              locale.substring(0, 2),
              Title,
            ]
          )
        )
      );

      return [sku, { tax, price, image, names }];
    })
  )
);
---

<script is:inline define:vars={{ products }}>
  window.replacePlaceholders = (content, data) => {
    const placeholderRegex =
      /<placeholder\s+name=(?:"|&#34;)(\w+)(?:"|&#34;)[^>]*><\/placeholder>/g;

    return content.replace(
      placeholderRegex,
      (_, placeholderName) => data[placeholderName]
    );
  };

  window.checkoutInfo = JSON.parse(
    localStorage.getItem("checkout-info") || "{}"
  );

  const queryParams = new URLSearchParams(location.search);

  if (queryParams.get("clear") === "cart") {
    localStorage.removeItem("cart");
  }

  const storedCart = JSON.parse(localStorage.getItem("cart") || "{}");

  Object.entries(storedCart).forEach(([SKU, inCartProductData]) => {
    const productData = products[SKU];

    if (!productData) {
      delete storedCart[SKU];
    } else if (
      inCartProductData.tax !== productData.tax ||
      inCartProductData.price !== productData.price ||
      inCartProductData.image !== productData.image ||
      inCartProductData.names !== productData.names
    ) {
      storedCart[SKU] = {
        ...inCartProductData,
        ...productData,
      };
    }
  });

  let subTotal, tax, shippingCost, total;

  const updateAmounts = (cart) => {
    [subTotal = 0, tax = 0] = Object.values(cart).reduce(
      ([priceSum, taxSum], { price, tax }) => [
        priceSum + Number(price),
        taxSum + Number(tax),
      ],
      [0, 0]
    );

    shippingCost = Number(window.checkoutInfo?.shipping_cost) || 0;

    total = subTotal + shippingCost;

    subTotal = subTotal.toFixed(2).replace(".", ",");
    tax = tax.toFixed(2).replace(".", ",");
    shippingCost = shippingCost?.toFixed(2)?.replace(".", ",");
    total = total?.toFixed(2)?.replace(".", ",");
  };

  updateAmounts(storedCart);

  const id = document.getElementById.bind(document),
    queryAll = document.querySelectorAll.bind(document);

  let cartSize, cartSubTotal, orderTotal, orderShippingCost;

  const updateUI = (cart) => {
    cartSize ??= id("cart-size");
    cartSubTotal ??= id("cart-subtotal");

    orderTotal ??= queryAll(".order-total");
    orderShippingCost ??= queryAll(".order-shipping-cost");

    updateAmounts(cart);

    cartSubTotal && (cartSubTotal.textContent = "€" + subTotal);
    cartSize && (cartSize.textContent = Object.values(cart).length);

    orderTotal.forEach((span) => (span.textContent = "€" + total));
    orderShippingCost.forEach(
      (span) => (span.textContent = "€" + shippingCost)
    );
  };

  window.cart = new Proxy(storedCart, {
    get(cart, property) {
      switch (property) {
        case "subTotal":
          return subTotal;

        case "tax":
          return tax;

        case "shippingCost":
          return shippingCost;

        case "total":
          return total;

        case "updateUI":
          return updateUI;

        default:
          return cart[property];
      }
    },

    set(cart, productId, productData) {
      const productExistsInCart = !!cart[productId];

      cart[productId] = productData;

      localStorage.setItem("cart", JSON.stringify(cart));

      updateUI(cart);

      if (productExistsInCart) {
        const cartProductElement = id(productId),
          cartProductAmountInputs = cartProductElement.querySelectorAll(
            ".cart-product-amount-input, .cart-overlay-product-amount-input"
          ),
          cartProductPriceElements = cartProductElement.querySelectorAll(
            ".cart-product-price, .cart-overlay-product-price"
          );

        cartProductAmountInputs.forEach((element) => {
          element.value = productData.quantity;
        });

        cartProductPriceElements.forEach((element) => {
          element.textContent =
            "€" + productData.price.toFixed(2).replace(".", ",");
        });
      } else {
        window.addProductToCart(productId);

        const newCartProductElement = id(productId),
          newProductAmountInput = newCartProductElement.querySelectorAll(
            ".cart-overlay-product-amount-input"
          ),
          newProductAmountTweakBtns = newCartProductElement.querySelectorAll(
            ".cart-overlay-product-amount-tweak-btn"
          );

        window.listenToInputEvents(
          newProductAmountTweakBtns,
          newProductAmountInput
        );

        if (Object.keys(cart).length === 1) {
          const cartOverlayContent = id("cart-overlay-content"),
            emptyCartNotification = id("empty-cart-notification");

          cartOverlayContent.classList.remove("hidden");
          emptyCartNotification.classList.add("hidden");
        }
      }

      return true;
    },

    deleteProperty(cart, property) {
      delete cart[property];

      localStorage.setItem("cart", JSON.stringify(cart));

      updateUI(cart);

      return true;
    },
  });
</script>
